-- Test cases for generating fine-grained dependencies for statements.
--
-- The dependencies are used for fined-grained incremental checking.

[case testIfStmt]
def f1() -> int: pass
def f2() -> None: pass
def f3() -> int: pass
def f4() -> None: pass
def f5() -> None: pass

def g() -> None:
    if f1():
        f2()
    elif f3():
        f4()
    else:
        f5()
[out]
<m.f1> -> m.g
<m.f2> -> m.g
<m.f3> -> m.g
<m.f4> -> m.g
<m.f5> -> m.g

[case testWhileStmt]
def f1() -> int: pass
def f2() -> None: pass
def f3() -> None: pass

def g() -> None:
    while f1():
        f2()
    else:
        f3()
[out]
<m.f1> -> m.g
<m.f2> -> m.g
<m.f3> -> m.g

[case testAssertStmt]
def f1() -> int: pass
def f2() -> str: pass
def f3() -> int: pass

def g() -> None:
    assert f1(), f2()
    assert f3()
[out]
<m.f1> -> m.g
<m.f2> -> m.g
<m.f3> -> m.g

[case testRaiseStmt]
def f1() -> BaseException: pass
def f2() -> BaseException: pass

def g1() -> None:
    raise f1()

def g2() -> None:
    raise f1() from f2()
[builtins fixtures/exception.pyi]
[out]
<m.f1> -> m.g1, m.g2
<m.f2> -> m.g2

[case testTryFinallyStmt]
def f1() -> None: pass
def f2() -> None: pass

def g() -> None:
    try:
        f1()
    finally:
        f2()
[out]
<m.f1> -> m.g
<m.f2> -> m.g

[case testPrintStmt_python2]
def f1(): # type: () -> int
    pass
def f2(): # type: () -> int
    pass

def g1(): # type: () -> None
    print f1()

def g2(): # type: () -> None
    print f1(), f2()
[out]
<m.f1> -> m.g1, m.g2
<m.f2> -> m.g2

[case testPrintStmtWithFile_python2]
class A:
    def write(self, s): # type: (str) -> None
        pass

def f1(): # type: () -> A
    pass
def f2(): # type: () -> int
    pass

def g(): # type: () -> None
    print >>f1(), f2()
[out]
<m.A.write> -> m.g
<m.A> -> <m.f1>, m.A, m.f1
<m.f2> -> m.g

[case testExecStmt_python2]
def f1(): pass
def f2(): pass
def f3(): pass

def g1(): # type: () -> None
    exec f1()

def g2(): # type: () -> None
    exec f1() in f2()

def g3(): # type: () -> None
    exec f1() in f2(), f3()
[out]
<m.f1> -> m.g1, m.g2, m.g3
<m.f2> -> m.g2, m.g3
<m.f3> -> m.g3

[case testForStmt]
from typing import Iterator

class A:
    def __iter__(self) -> Iterator[int]: pass

def f1() -> None: pass
def f2() -> None: pass

def g() -> None:
    a: A
    for x in a:
        f1()
    else:
        f2()
[builtins fixtures/list.pyi]
[out]
<m.A.__iter__> -> m.g
<m.A> -> m.A, m.g
<m.f1> -> m.g
<m.f2> -> m.g

[case testTryExceptStmt]
class A(BaseException): pass
class B(BaseException):
    def f(self) -> None: pass

def f1() -> None: pass
def f2() -> None: pass
def f3() -> None: pass

def g() -> None:
    try:
        f1()
    except A:
        f2()
    except B as e:
        e.f()
    else:
        f3()
[builtins fixtures/exception.pyi]
[out]
<m.A> -> m.A, m.g
<m.B.f> -> m.g
<m.B> -> m.B, m.g
<m.f1> -> m.g
<m.f2> -> m.g
<m.f3> -> m.g

[case testTryExceptStmt2]
class A(BaseException): pass
class B(BaseException):
    def f(self) -> None: pass

def f1() -> None: pass
def f2() -> None: pass

def g() -> None:
    try:
        f1()
    except (A, B):
        f2()
[builtins fixtures/exception.pyi]
[out]
<m.A> -> m.A, m.g
<m.B> -> m.B, m.g
<m.f1> -> m.g
<m.f2> -> m.g

[case testWithStmt]
from typing import Any
class A:
    def __enter__(self) -> 'B': pass
    def __exit__(self, a, b, c) -> None: pass

class B:
    def f(self) -> None: pass

def g() -> None:
    a: A
    with a as x:
        x.f()
[out]
<m.A.__enter__> -> m.g
<m.A.__exit__> -> m.g
<m.A> -> m.A, m.g
<m.B.f> -> m.g
<m.B> -> <m.A.__enter__>, m.A.__enter__, m.B

[case testWithStmt2]
from typing import Any
class A:
    def __enter__(self) -> 'C': pass
    def __exit__(self, a, b, c) -> None: pass
class B:
    def __enter__(self) -> 'D': pass
    def __exit__(self, a, b, c) -> None: pass

class C: pass
class D: pass

def g() -> None:
    a: A
    b: B
    with a as x, b as y:
        pass
[out]
<m.A.__enter__> -> m.g
<m.A.__exit__> -> m.g
<m.A> -> m.A, m.g
<m.B.__enter__> -> m.g
<m.B.__exit__> -> m.g
<m.B> -> m.B, m.g
<m.C> -> <m.A.__enter__>, m.A.__enter__, m.C
<m.D> -> <m.B.__enter__>, m.B.__enter__, m.D

[case testWithStmtAnnotation]
from typing import Any
class A:
    def __enter__(self) -> Any: pass
    def __exit__(self, a, b, c) -> None: pass

class B: pass

def f(b: B) -> None: pass

def g() -> None:
    a: A
    with a as x: # type: B
        f(x)
[out]
<m.A.__enter__> -> m.g
<m.A.__exit__> -> m.g
<m.A> -> m.A, m.g
<m.B> -> <m.f>, m.B, m.f, m.g
<m.f> -> m.g

[case testForStmtAnnotation]
class A:
    def __iter__(self): pass

class B:
    def f(self) -> None: pass

def g() -> None:
    a: A
    for x in a: # type: B
        x.f()
[builtins fixtures/list.pyi]
[out]
<m.A.__iter__> -> m.g
<m.A> -> m.A, m.g
<m.B.f> -> m.g
<m.B> -> m.B, m.g
